#include "lim_try.hlsli"

#define POINT 0
#define LINEAR 1
#define ANISOTROPIC 2
#define LINEAR_BORDER_BLACK 3
#define LINEAR_BORDER_WHITE 4

SamplerState sampler_states[3] : register(s0);
Texture2D texture_maps[8] : register(t0);

Texture2D noise_map : register(t9); // 先生ノイズは3D

Texture2D roughness_ : register(t4);
Texture2D metalness_ : register(t5);

// SHADOW
SamplerComparisonState comparison_sampler_state : register(s5);
Texture2D shadow_map : register(t8);

///////////////////////////////////////////
// シェーダーリソース
///////////////////////////////////////////
// モデルテクスチャ

///////////////////////////////////////////
// サンプラーステート
///////////////////////////////////////////
sampler g_sampler : register(s0);

float4 main(VS_OUT pin) : SV_TARGET
{
    // サンプリング
    float4 color = texture_maps[0].Sample(sampler_states[ANISOTROPIC], pin.texcoord);
    float alpha = color.a;
    
    // 金属度
    float metallic = metalness_.Sample(sampler_states[ANISOTROPIC], pin.texcoord);
    
    // 滑らかさ
    float smoothness = roughness_.Sample(sampler_states[ANISOTROPIC], pin.texcoord);
    // 粗さ
    float roughness = 1.0f - smoothness;
#if 0
    // 調整
    metallic = saturate(metallic + adjustMetalness);
    smoothness = saturate(smoothness + adjustSmoothness);
 #endif
    
     //FOG
    {
        color = CalcFog(color, dis_fog_color, dis_fog_range.xy, length(pin.world_position.xyz - camera_position.xyz));
    }
    
    // 入射光のうち拡散反射になる割合
    float3 diffuseReflectance = lerp(color.rgb, 0.02f, metallic);
   // 垂直反射時のフレネル反射率
    float3 F0 = lerp(Dielectric, color.rgb, metallic);
    
    // 法線
    float3 N_ = normalize(pin.world_normal.xyz);
    // 接ベクトル
    float3 T = normalize(pin.world_tangent.xyz);
    float sigma = pin.world_tangent.w;
    // 接ベクトルは法線マップから計算され、法線ベクトル N と直交するように調整
    T = normalize(T - N_ * dot(N_, T));
    // 従ベクトル
    float3 B = normalize(cross(N_, T) * sigma);
    
    // 法線マップからxyz成分を取得して( -1 〜 +1 )の間にスケーリング
    float3 normal = texture_maps[1].Sample(sampler_states[LINEAR], pin.texcoord).xyz * 2.0f - 1.0f;
    float3 N = normalize(normal.x * normalize(T) + normal.y * normalize(B) + normal.z * normalize(N_));
    float3 E = normalize(camera_position.xyz - pin.world_position.xyz);
    // ライティング計算
    
    float3 directDiffuse = 0, directSpecular = 0;
    
    // 平行光源の処理
    DirectBDRF(diffuseReflectance, F0, N, E, directional_light_direction.xyz,
         directional_light_color.rgb, roughness,
         directDiffuse, directSpecular);
    
    
#if 1
    // スポットライトの処理（PBR無し）
    for (int j = 0; j < 1; ++j)
    {
        // サーフェイスに入射するスポットライトの光の向きを計算する
        float3 ligDir = pin.world_position.xyz - spot_light[j].position.xyz;
        // スポットライトのカラー
        float3 spColor = spot_light[j].color.xyz;
        // 正規化して大きさ1のベクトルにする
        ligDir = normalize(ligDir);
        
        // 減衰なしのLambert拡散反射光を計算する
        float3 diffSpotLight = CalcLambertDiffuse(
        ligDir, // ライトの方向
        spColor, // ライトのカラー
        pin.world_normal.rgb // サーフェイスの法線
        );
        // 減衰なしのPhong鏡面反射光を計算する
            float3 specSpotLight = CalcPhongSpecular(
            ligDir, // ライトの方向
            spColor, // ライトのカラー
            pin.world_position.rgb, // サーフェイスのワールド座標
            pin.world_normal.rgb     // サーフェイスの法線
        );
        
        
        // 距離による影響率を計算する
        // スポットライトとの距離を計算する
        float3 distance = length(pin.world_position.xyz - spot_light[j].position.xyz);

        // 影響率は距離に比例して小さくなっていく
        float affect = 1.0f - 1.0f / spot_light[j].range * distance;
        
        // 影響力がマイナスにならないように補正をかける
        if (affect < 0.0f)
        {
            affect = 0.0f;
        }

        // 影響の仕方を指数関数的にする
        affect = pow(affect, 6.0f);
        
        // 影響率を乗算して反射光を弱める
        diffSpotLight *= affect;
        specSpotLight *= affect;
        
        // 入射光と射出方向の角度を求める
        // dot()を利用して内積を求める
        float angle = dot(ligDir, spot_light[j].direction.xyz);
        
        // dot()で求めた値をacos()に渡して角度を求める
        angle = abs(acos(angle));
        
        // 角度による影響率を求める
        // 角度に比例して小さくなっていく影響率を計算する
        affect = 1.0f - 1.0f / spot_light[j].angle * angle;

        // 影響率がマイナスにならないように補正をかける
        if (affect < 0.0f)
        {
            affect = 0.0f;
        }
        
        // 影響の仕方を指数関数的にする。今回のサンプルでは0.5乗している
        affect = pow(affect, 0.5f);

        // 角度による影響率を反射光に乗算して、影響を弱める
        diffSpotLight *= affect;
        specSpotLight *= affect;
        
        directDiffuse += diffSpotLight;
        directSpecular += specSpotLight;
        
    }
#else

    // 点光源の処理
    for (int i = 0; i < 8; ++i)
    {
        // サーフェイスに入射するライトの光の向きを計算する
        float3 lightVector = pin.world_position.xyz - point_light[i].position.xyz;
        float lightLength = length(lightVector);
        if (lightLength >= point_light[i].range)
            continue;
        float attenuate = saturate(1.0f - lightLength / point_light[i].range);
        lightVector = lightVector / lightLength;
        
        // ポイントライトとの距離を計算する
        float3 distance = length(pin.world_position.xyz - point_light[i].position.xyz);
        // 影響率は距離に比例して小さくなっていく
        float affect = 1.0f - 1.0f / point_light[i].range.x * distance;
        // 影響力がマイナスにならないように補正をかける
        if (affect < 0.0f)
        {
            affect = 0.0f;
        }
        //影響を指数関数的にする。今回のサンプルでは3乗している
        affect = pow(affect, 3.0f);
        
        float3 diffuse = 0, specular = 0;
        DirectBDRF(diffuseReflectance, F0, N, E, lightVector,
        point_light[i].color.rgb, roughness,
        diffuse, specular);
        
        directDiffuse += diffuse * attenuate;
        directSpecular += specular * attenuate;
    }
    
    
#endif
    
    // ディゾルブ
    {
        float mask = noise_map.Sample(sampler_states[ANISOTROPIC], pin.texcoord).x;
    
        // step関数を用いてmaskの値とdissolveThresholdの値を比較して透過値を0 or 1にする
        float dissolve = step(mask, threshold);
        // colorの透過値に乗算する
        //color.a *= mask;
        color.a *= dissolve;
        // アルファが0以下ならそもそも描画しないようにする
        clip(color.a - 0.01f);
    }
    
    // SHADOW
#if 0
    const float shadow_depth_bias = 0.001;
#else
    float3 L = normalize(-directional_light_direction.xyz);
    float3 SN = normalize(pin.world_normal.xyz);
    float3 s_normal = texture_maps[1].Sample(sampler_states[LINEAR], pin.texcoord).xyz;
    SN = normalize((s_normal.x * T) + (s_normal.y * B) + (s_normal.z * SN));
	// Here we have a maximum bias of 0.01 and a minimum of 0.001 based on the surface's normal and light direction. 
    const float shadow_depth_bias = max(0.01 * (1.0 - dot(SN, L)), 0.001);
#endif

    float4 light_view_position = mul(pin.world_position, light_view_projection);
    light_view_position = light_view_position / light_view_position.w;
    float2 light_view_texcoord = 0;
    light_view_texcoord.x = light_view_position.x * +0.5 + 0.5;
    light_view_texcoord.y = light_view_position.y * -0.5 + 0.5;
    float depth = saturate(light_view_position.z - shadow_depth_bias);

    float3 shadow_factor = 1.0f;
    shadow_factor = shadow_map.SampleCmpLevelZero(comparison_sampler_state, light_view_texcoord, depth).xxx;
    

    float3 hemiLight = 0;
 // リムライト（並行光源とぶつかるため要修正）
#if 0
    // ライト方向ベクトル
    float3 Light = normalize(directional_light_direction.xyz);
    // 各ベクトルを正規化し、それらを行列の各列に割り当て
   float3x3 mat = { T, pin.binormal, N_ };
    // 法線マップのサンプリング
    float3 RimN = texture_maps[1].Sample(sampler_states[ANISOTROPIC], pin.texcoord).rgb;
    // ノーマルテクスチャ法線をワールドへ変換
    RimN = normalize(mul(RimN * 2.0f - 1.0f, mat));
    
    float3 rimColor = CalcRimLight(RimN, -E, Light, directional_light_color.rgb);
    
    directDiffuse += rimColor;
    // 半球ライト
    hemiLight = CalcHemiSphereLight(RimN, float3(0, 1, 0), sky_color.rgb, ground_color.rgb, hemisphere_weight);
    
#endif
    
    return float4((directDiffuse + directSpecular + hemiLight) * shadow_factor /*SHADOW*/, color.a);

}